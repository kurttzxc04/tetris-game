<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris — Single File</title>
  <style>
    :root{
      --bg:#0b0f1a;
      --panel:#0f1724;
      --muted:#9aa6bf;
    }
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#081026 0%, #071428 100%);color:#e6eef8}
    .wrap{height:100%;display:flex;align-items:center;justify-content:center;gap:24px;padding:24px;box-sizing:border-box}
    .game{display:flex;gap:18px}
    canvas{background:var(--panel);image-rendering:pixelated;border-radius:8px;box-shadow:0 8px 30px rgba(2,6,23,.6)}
    .ui{width:220px;padding:18px;border-radius:10px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));box-shadow:0 6px 20px rgba(2,6,23,.5)}
    .ui h1{font-size:18px;margin:0 0 10px;color:#f6fbff}
    .stat{display:flex;justify-content:space-between;padding:6px 0;color:var(--muted)}
    .controls{font-size:13px;margin-top:12px;color:var(--muted)}
    button{margin-top:12px;padding:8px 10px;border-radius:8px;border:0;background:#1b2430;color:#dfe9ff;cursor:pointer}
    .small{font-size:12px;color:#9fb0d9}
    footer{position:fixed;left:12px;bottom:12px;color:#7f94bb;font-size:12px}
    .overlay-center{position:absolute;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;pointer-events:none}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="game">
      <div style="position:relative;">
        <canvas id="tetris" width="240" height="480"></canvas>
      </div>
      <div class="ui">
        <h1>TETRIS</h1>
        <div class="stat"><span>Score</span><strong id="score">0</strong></div>
        <div class="stat"><span>Level</span><strong id="level">1</strong></div>
        <div class="stat"><span>Lines</span><strong id="lines">0</strong></div>
        <div style="height:10px"></div>
        <div class="small">Controls</div>
        <div class="controls">
          Left / Right: ← →<br>
          Soft drop: ↓<br>
          Hard drop: Space<br>
          Rotate: Up or Q / E<br>
          Pause: P — Restart: R
        </div>
        <button id="btnPause">Pause (P)</button>
        <button id="btnRestart">Restart (R)</button>
      </div>
    </div>
  </div>
  <footer>Single-file Tetris — open this file in your browser to play</footer>

<script>
// ---- Configuration ----
const COLS = 10;
const ROWS = 20;
const BLOCK = 24; // pixel size of block
const canvas = document.getElementById('tetris');
canvas.width = COLS * BLOCK;
canvas.height = ROWS * BLOCK;
const ctx = canvas.getContext('2d');

// Colors for pieces (index 1..7)
const COLORS = [null, '#FF6B6B', '#FFD93D', '#6BCB77', '#4D96FF', '#A36BFF', '#FF8AC1', '#00E5FF'];

// Piece definitions using matrices
const PIECES = {
  I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
  J: [[2,0,0],[2,2,2],[0,0,0]],
  L: [[0,0,3],[3,3,3],[0,0,0]],
  O: [[4,4],[4,4]],
  S: [[0,5,5],[5,5,0],[0,0,0]],
  T: [[0,6,0],[6,6,6],[0,0,0]],
  Z: [[7,7,0],[0,7,7],[0,0,0]]
};
const PIECE_KEYS = Object.keys(PIECES);

// ---- Game state ----
let arena = createMatrix(COLS, ROWS);
let player = {
  pos: {x:0,y:0},
  matrix: null,
  score:0,
  lines:0,
  level:1
};
let dropCounter = 0;
let dropInterval = 1000; // ms
let lastTime = 0;
let paused = false;
let gameOver = false;

// ---- Utility Functions ----
function createMatrix(w,h){
  const m = [];
  for(let y=0;y<h;y++){
    m.push(new Array(w).fill(0));
  }
  return m;
}

function drawCell(x,y,value){
  if(value===0) return;
  ctx.fillStyle = COLORS[value];
  ctx.fillRect(x*BLOCK+1, y*BLOCK+1, BLOCK-2, BLOCK-2);
}

function mergeDraw(matrix, offset){
  matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value!==0){
        drawCell(x+offset.x, y+offset.y, value);
      }
    });
  });
}

function draw(){
  // background
  ctx.fillStyle = '#0b1220';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // draw arena
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const val = arena[y][x];
      if(val) drawCell(x,y,val);
      else {
        ctx.strokeStyle = 'rgba(255,255,255,0.02)';
        ctx.strokeRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK);
      }
    }
  }

  // draw player
  if(player.matrix) mergeDraw(player.matrix, player.pos);

  // --- GAME OVER OVERLAY ---
  if(gameOver){
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.fillStyle = '#ff4d4d';
    ctx.font = 'bold 32px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('OUT OF BOUND', canvas.width/2, canvas.height/2);

    ctx.fillStyle = '#dfe9ff';
    ctx.font = '14px Arial';
    ctx.fillText('Press R to Restart', canvas.width/2, canvas.height/2 + 36);
  }
}

function collide(arena, player){
  const m = player.matrix;
  const o = player.pos;
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      if(m[y][x]!==0 && (arena[y+o.y] && arena[y+o.y][x+o.x])!==0){
        return true;
      }
    }
  }
  return false;
}

function merge(arena, player){
  player.matrix.forEach((row,y)=>{
    row.forEach((val,x)=>{
      if(val!==0) arena[y+player.pos.y][x+player.pos.x] = val;
    });
  });
}

function rotate(matrix, dir){
  // transpose
  for(let y=0;y<matrix.length;y++){
    for(let x=0;x<y;x++){
      [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
    }
  }
  if(dir>0) matrix.forEach(row=>row.reverse());
  else matrix.reverse();
}

function playerDrop(){
  player.pos.y++;
  if(collide(arena, player)){
    player.pos.y--;
    merge(arena, player);
    sweepLines();
    playerReset();
    updateScore();
  }
  dropCounter = 0;
}

function hardDrop(){
  while(!collide(arena, player)){
    player.pos.y++;
  }
  player.pos.y--;
  merge(arena, player);
  sweepLines();
  playerReset();
  updateScore();
  dropCounter = 0;
}

function playerMove(dir){
  player.pos.x += dir;
  if(collide(arena, player)) player.pos.x -= dir;
}

function playerRotate(dir){
  const pos = player.pos.x;
  let offset = 1;
  rotate(player.matrix, dir);
  while(collide(arena, player)){
    player.pos.x += offset;
    offset = -(offset + (offset>0?1:-1));
    if(Math.abs(offset) > player.matrix[0].length){
      rotate(player.matrix, -dir);
      player.pos.x = pos;
      return;
    }
  }
}

function sweepLines(){
  let rowCount = 0;
  outer: for(let y=arena.length-1;y>=0;y--){
    for(let x=0;x<arena[y].length;x++){
      if(arena[y][x]===0) {
        continue outer;
      }
    }
    const row = arena.splice(y,1)[0].fill(0);
    arena.unshift(row);
    y++;
    rowCount++;
  }
  if(rowCount>0){
    // scoring (classic): 1->40,2->100,3->300,4->1200 multiplied by level
    const points = [0,40,100,300,1200];
    player.score += points[rowCount] * player.level;
    player.lines += rowCount;
    // level up every 10 lines
    const newLevel = Math.floor(player.lines/10) + 1;
    if(newLevel > player.level){
      player.level = newLevel;
      dropInterval = Math.max(100, dropInterval - 100 * (player.level-1));
    }
  }
}

function playerReset(){
  const key = PIECE_KEYS[Math.floor(Math.random()*PIECE_KEYS.length)];
  player.matrix = PIECES[key].map(row=>row.slice());
  player.pos.y = 0;
  player.pos.x = Math.floor((COLS - player.matrix[0].length)/2);
  if(collide(arena, player)){
    // Game over
    arena = createMatrix(COLS, ROWS);
    gameOver = true;
    paused = true;
  }
}

function updateScore(){
  document.getElementById('score').textContent = player.score;
  document.getElementById('level').textContent = player.level;
  document.getElementById('lines').textContent = player.lines;
}

// ---- Game loop ----
function update(time = 0){
  if(paused) return;
  const deltaTime = time - lastTime;
  lastTime = time;
  dropCounter += deltaTime;
  if(dropCounter > dropInterval){
    playerDrop();
  }
  draw();
  if(!paused) requestAnimationFrame(update);
}

// ---- Input ----
document.addEventListener('keydown', event => {
  if(event.key === 'ArrowLeft') playerMove(-1);
  else if(event.key === 'ArrowRight') playerMove(1);
  else if(event.key === 'ArrowDown') playerDrop();
  else if(event.key === ' ') { event.preventDefault(); hardDrop(); }
  else if(event.key === 'ArrowUp' || event.key.toLowerCase()==='x') playerRotate(1);
  else if(event.key.toLowerCase() === 'q') playerRotate(-1);
  else if(event.key.toLowerCase() === 'e') playerRotate(1);
  else if(event.key.toLowerCase() === 'p') togglePause();
  else if(event.key.toLowerCase() === 'r') restart();
  updateScore();
});

// Buttons
document.getElementById('btnRestart').addEventListener('click', restart);
document.getElementById('btnPause').addEventListener('click', togglePause);

function togglePause(){
  const btn = document.getElementById('btnPause');
  if(gameOver){
    restart();
    return;
  }
  paused = !paused;
  btn.textContent = paused ? 'Resume (P)' : 'Pause (P)';
  if(!paused){ lastTime = performance.now(); requestAnimationFrame(update); }
}

function restart(){
  arena = createMatrix(COLS, ROWS);
  player.score = 0; player.lines = 0; player.level = 1;
  dropInterval = 1000;
  gameOver = false; paused = false;
  playerReset();
  updateScore();
  document.getElementById('btnPause').textContent = 'Pause (P)';
  lastTime = performance.now();
  requestAnimationFrame(update);
}

// Start
playerReset();
updateScore();
document.getElementById('btnPause').textContent = 'Pause (P)';
requestAnimationFrame(update);

</script>
</body>
</html>