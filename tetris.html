<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tetris — Single File</title>
  <style>
    :root{
      --bg:#0b0f1a;
      --panel:#0f1724;
      --muted:#9aa6bf;
    }
    html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Helvetica,Arial,sans-serif;background:linear-gradient(180deg,#081026 0%, #071428 100%);color:#e6eef8}
    .wrap{height:100%;display:flex;align-items:center;justify-content:center;gap:24px;padding:24px;box-sizing:border-box}
    .game{display:flex;gap:18px}
    canvas{background:var(--panel);image-rendering:pixelated;border-radius:8px;box-shadow:0 8px 30px rgba(2,6,23,.6)}
    .ui{width:220px;padding:18px;border-radius:10px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));box-shadow:0 6px 20px rgba(2,6,23,.5)}
    .ui h1{font-size:18px;margin:0 0 10px;color:#f6fbff}
    .stat{display:flex;justify-content:space-between;padding:6px 0;color:var(--muted)}
    .controls{font-size:13px;margin-top:12px;color:var(--muted)}
    button{margin-top:12px;padding:10px 12px;border-radius:8px;border:0;background:#1b2430;color:#dfe9ff;cursor:pointer;transition:all 0.3s ease;font-weight:500}
    button:hover:not(:disabled){background:#2a3a50;}
    button:disabled{opacity:0.4;cursor:not-allowed}
    button:not(:disabled):active{transform:scale(0.98)}
    .small{font-size:12px;color:#9fb0d9}
    footer{position:fixed;left:12px;bottom:12px;color:#7f94bb;font-size:12px}
    .overlay-center{position:absolute;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;pointer-events:none}
    #difficultyMenu{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.85);display:flex;align-items:center;justify-content:center;z-index:1000}
    .difficulty-container{text-align:center;background:linear-gradient(180deg,rgba(30,50,80,0.9),rgba(20,35,60,0.9));padding:40px;border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,0.8);border:2px solid rgba(100,150,255,0.3)}
    .difficulty-container h2{font-size:32px;margin:0 0 30px;color:#dfe9ff}
    .difficulty-btn{width:180px;padding:16px 20px;font-size:18px;margin:10px;border:2px solid rgba(100,150,255,0.5);background:#1b2430;color:#dfe9ff;cursor:pointer;border-radius:10px;transition:all 0.3s ease;font-weight:bold}
    .difficulty-btn:hover{background:#2a3a50;border-color:#4D96FF;box-shadow:0 0 15px rgba(77,150,255,0.4)}
    .next-preview-panel{width:120px;display:flex;flex-direction:column;gap:12px}
    .next-preview{padding:12px;background:rgba(15,23,36,0.8);border-radius:8px;border:1px solid rgba(100,150,255,0.3)}
    .next-preview h3{margin:0 0 8px;font-size:12px;color:#9fb0d9;text-transform:uppercase;letter-spacing:1px}
    .next-preview-canvas{width:100%;height:100px;background:#0b1220;border-radius:4px;display:block}
    .ui{transition:opacity 0.3s ease,filter 0.3s ease;pointer-events:auto}
    .ui.game-over{opacity:0.45;filter:blur(1px);pointer-events:none}
    .ui.game-over button{opacity:0.4}
    .game-over-overlay{position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);display:none;align-items:center;justify-content:center;z-index:2000;backdrop-filter:blur(2px)}
    .game-over-overlay.active{display:flex}
    .game-over-content{text-align:center;background:linear-gradient(180deg,rgba(30,50,80,0.95),rgba(20,35,60,0.95));padding:60px 40px;border-radius:16px;box-shadow:0 20px 60px rgba(0,0,0,0.9);border:2px solid rgba(100,150,255,0.4);animation:slideIn 0.4s ease-out}
    .game-over-content h2{font-size:48px;margin:0 0 20px;color:#ff6b6b;font-weight:bold}
    .game-over-content p{font-size:18px;color:#dfe9ff;margin:10px 0;letter-spacing:0.5px}
    .game-over-button{padding:16px 32px;font-size:18px;margin:20px auto;border:2px solid #4D96FF;background:linear-gradient(135deg,#4D96FF,#6BCB77);color:#fff;cursor:pointer;border-radius:10px;transition:all 0.3s ease;font-weight:bold;display:inline-block}
    .game-over-button:hover{box-shadow:0 0 30px rgba(77,150,255,0.8);transform:scale(1.05)}
    .game-over-button:active{transform:scale(0.98)}
    @keyframes slideIn{0%{transform:translateY(-50px);opacity:0;}100%{transform:translateY(0);opacity:1;}}
    #btnRestart.active{background:linear-gradient(135deg,#4D96FF,#6BCB77);color:#fff;font-weight:bold;animation:pulse 1.5s ease-in-out infinite;box-shadow:0 0 20px rgba(77,150,255,0.6)}
    @keyframes pulse{0%{box-shadow:0 0 15px rgba(77,150,255,0.5);}50%{box-shadow:0 0 30px rgba(77,150,255,0.8);}100%{box-shadow:0 0 15px rgba(77,150,255,0.5);}}
  </style>
</head>
<body>
  <div id="difficultyMenu" style="display:flex;">
    <div class="difficulty-container">
      <h2>Select Difficulty</h2>
      <button class="difficulty-btn" onclick="startGame('easy')">Easy</button>
      <button class="difficulty-btn" onclick="startGame('normal')">Normal</button>
    </div>
  </div>
  <div class="game-over-overlay" id="gameOverOverlay">
    <div class="game-over-content">
      <h2>GAME OVER</h2>
      <p id="gameOverScore">Score: 0</p>
      <p id="gameOverLevel">Level: 1</p>
      <p id="gameOverLines">Lines: 0</p>
      <button class="game-over-button" onclick="restart()">Play Again</button>
    </div>
  </div>
  <div class="wrap" style="display:none;" id="gameContainer">
    <div class="game">
      <div style="position:relative;">
        <canvas id="tetris" width="240" height="480"></canvas>
        <div id="nextPreviewPanel" class="next-preview-panel" style="display:none;">
          <div class="next-preview">
            <h3>Next Piece</h3>
            <canvas id="nextPreview" width="96" height="96" class="next-preview-canvas"></canvas>
          </div>
        </div>
      </div>
      <div class="ui">
        <h1>TETRIS</h1>
        <div class="stat"><span>Score</span><strong id="score">0</strong></div>
        <div class="stat"><span>Level</span><strong id="level">1</strong></div>
        <div class="stat"><span>Lines</span><strong id="lines">0</strong></div>
        <div style="height:10px"></div>
        <div class="small">Controls</div>
        <div class="controls">
          Left / Right: ← →<br>
          Soft drop: ↓<br>
          Hard drop: Space<br>
          Rotate: Up or Q / E<br>
          Pause: P — Restart: R
        </div>
        <button id="btnPause">Pause (P)</button>
        <button id="btnRestart">Restart (R)</button>
      </div>
    </div>
  </div>
  <footer>Single-file Tetris — open this file in your browser to play</footer>

<script>
// ---- Configuration ----
const COLS = 10;
const ROWS = 20;
const BLOCK = 24; // pixel size of block
const canvas = document.getElementById('tetris');
canvas.width = COLS * BLOCK;
canvas.height = ROWS * BLOCK;
const ctx = canvas.getContext('2d');
const previewCanvas = document.getElementById('nextPreview');
const previewCtx = previewCanvas.getContext('2d');

// Colors for pieces (index 1..7)
const COLORS = [null, '#FF6B6B', '#FFD93D', '#6BCB77', '#4D96FF', '#A36BFF', '#FF8AC1', '#00E5FF'];

// Piece definitions using matrices
const PIECES = {
  I: [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
  J: [[2,0,0],[2,2,2],[0,0,0]],
  L: [[0,0,3],[3,3,3],[0,0,0]],
  O: [[4,4],[4,4]],
  S: [[0,5,5],[5,5,0],[0,0,0]],
  T: [[0,6,0],[6,6,6],[0,0,0]],
  Z: [[7,7,0],[0,7,7],[0,0,0]]
};
const PIECE_KEYS = Object.keys(PIECES);

// ---- Game state ----
let arena = createMatrix(COLS, ROWS);
let player = {
  pos: {x:0,y:0},
  matrix: null,
  score:0,
  lines:0,
  level:1
};
let nextPiece = null;
let dropCounter = 0;
let dropInterval = 1000; // ms
let lastTime = 0;
let paused = false;
let gameOver = false;
let difficulty = null; // 'easy' or 'normal'

// ---- Utility Functions ----
function createMatrix(w,h){
  const m = [];
  for(let y=0;y<h;y++){
    m.push(new Array(w).fill(0));
  }
  return m;
}

function drawCell(x,y,value,context=ctx,blockSize=BLOCK){
  if(value===0) return;
  context.fillStyle = COLORS[value];
  context.fillRect(x*blockSize+1, y*blockSize+1, blockSize-2, blockSize-2);
}

function drawNextPreview(){
  if(!nextPiece || difficulty !== 'easy') return;
  
  // Clear preview canvas
  previewCtx.fillStyle = '#0b1220';
  previewCtx.fillRect(0, 0, previewCanvas.width, previewCanvas.height);
  
  // Draw grid
  previewCtx.strokeStyle = 'rgba(255,255,255,0.1)';
  const smallBlock = 12;
  for(let y=0; y<4; y++){
    for(let x=0; x<4; x++){
      previewCtx.strokeRect(x*smallBlock, y*smallBlock, smallBlock, smallBlock);
    }
  }
  
  // Draw piece
  nextPiece.forEach((row, y) => {
    row.forEach((value, x) => {
      if(value !== 0){
        previewCtx.fillStyle = COLORS[value];
        previewCtx.fillRect(x*smallBlock+1, y*smallBlock+1, smallBlock-2, smallBlock-2);
      }
    });
  });
}

function mergeDraw(matrix, offset){
  matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value!==0){
        drawCell(x+offset.x, y+offset.y, value);
      }
    });
  });
}

function draw(){
  // background
  ctx.fillStyle = '#0b1220';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // draw arena
  for(let y=0;y<ROWS;y++){
    for(let x=0;x<COLS;x++){
      const val = arena[y][x];
      if(val) drawCell(x,y,val);
      else {
        ctx.strokeStyle = 'rgba(255,255,255,0.02)';
        ctx.strokeRect(x*BLOCK,y*BLOCK,BLOCK,BLOCK);
      }
    }
  }

  // draw player
  if(player.matrix) mergeDraw(player.matrix, player.pos);
}

function collide(arena, player){
  const m = player.matrix;
  const o = player.pos;
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      if(m[y][x]!==0 && (arena[y+o.y] && arena[y+o.y][x+o.x])!==0){
        return true;
      }
    }
  }
  return false;
}

function merge(arena, player){
  player.matrix.forEach((row,y)=>{
    row.forEach((val,x)=>{
      if(val!==0) arena[y+player.pos.y][x+player.pos.x] = val;
    });
  });
}

function rotate(matrix, dir){
  // transpose
  for(let y=0;y<matrix.length;y++){
    for(let x=0;x<y;x++){
      [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
    }
  }
  if(dir>0) matrix.forEach(row=>row.reverse());
  else matrix.reverse();
}

function playerDrop(){
  player.pos.y++;
  if(collide(arena, player)){
    player.pos.y--;
    merge(arena, player);
    sweepLines();
    playerReset();
    updateScore();
  }
  dropCounter = 0;
}

function hardDrop(){
  while(!collide(arena, player)){
    player.pos.y++;
  }
  player.pos.y--;
  merge(arena, player);
  sweepLines();
  playerReset();
  updateScore();
  dropCounter = 0;
}

function playerMove(dir){
  player.pos.x += dir;
  if(collide(arena, player)) player.pos.x -= dir;
}

function playerRotate(dir){
  const pos = player.pos.x;
  let offset = 1;
  rotate(player.matrix, dir);
  while(collide(arena, player)){
    player.pos.x += offset;
    offset = -(offset + (offset>0?1:-1));
    if(Math.abs(offset) > player.matrix[0].length){
      rotate(player.matrix, -dir);
      player.pos.x = pos;
      return;
    }
  }
}

function sweepLines(){
  let rowCount = 0;
  outer: for(let y=arena.length-1;y>=0;y--){
    for(let x=0;x<arena[y].length;x++){
      if(arena[y][x]===0) {
        continue outer;
      }
    }
    const row = arena.splice(y,1)[0].fill(0);
    arena.unshift(row);
    y++;
    rowCount++;
  }
  if(rowCount>0){
    // scoring (classic): 1->40,2->100,3->300,4->1200 multiplied by level
    const points = [0,40,100,300,1200];
    player.score += points[rowCount] * player.level;
    player.lines += rowCount;
    // level up every 10 lines
    const newLevel = Math.floor(player.lines/10) + 1;
    if(newLevel > player.level){
      player.level = newLevel;
      dropInterval = Math.max(100, dropInterval - 100 * (player.level-1));
    }
  }
}

function playerReset(){
  // Move next piece to current
  if(nextPiece){
    player.matrix = nextPiece.map(row=>row.slice());
  } else {
    const key = PIECE_KEYS[Math.floor(Math.random()*PIECE_KEYS.length)];
    player.matrix = PIECES[key].map(row=>row.slice());
  }
  
  // Generate new next piece
  const key = PIECE_KEYS[Math.floor(Math.random()*PIECE_KEYS.length)];
  nextPiece = PIECES[key].map(row=>row.slice());
  drawNextPreview();
  
  player.pos.y = 0;
  player.pos.x = Math.floor((COLS - player.matrix[0].length)/2);
  if(collide(arena, player)){
    // Game over
    arena = createMatrix(COLS, ROWS);
    gameOver = true;
    paused = true;
    showGameOver();
  }
}

function updateScore(){
  document.getElementById('score').textContent = player.score;
  document.getElementById('level').textContent = player.level;
  document.getElementById('lines').textContent = player.lines;
}

// ---- Game loop ----
function update(time = 0){
  if(paused) return;
  const deltaTime = time - lastTime;
  lastTime = time;
  dropCounter += deltaTime;
  if(dropCounter > dropInterval){
    playerDrop();
  }
  draw();
  if(!paused) requestAnimationFrame(update);
}

// ---- Input ----
document.addEventListener('keydown', event => {
  if(gameOver){
    if(event.key.toLowerCase() === 'r') restart();
    return;
  }
  if(event.key === 'ArrowLeft') playerMove(-1);
  else if(event.key === 'ArrowRight') playerMove(1);
  else if(event.key === 'ArrowDown') playerDrop();
  else if(event.key === ' ') { event.preventDefault(); hardDrop(); }
  else if(event.key === 'ArrowUp' || event.key.toLowerCase()==='x') playerRotate(1);
  else if(event.key.toLowerCase() === 'q') playerRotate(-1);
  else if(event.key.toLowerCase() === 'e') playerRotate(1);
  else if(event.key.toLowerCase() === 'p') togglePause();
  else if(event.key.toLowerCase() === 'r') restart();
  updateScore();
});

// Buttons
document.getElementById('btnRestart').addEventListener('click', restart);
document.getElementById('btnPause').addEventListener('click', togglePause);

function togglePause(){
  const btn = document.getElementById('btnPause');
  if(gameOver){
    restart();
    return;
  }
  paused = !paused;
  btn.textContent = paused ? 'Resume (P)' : 'Pause (P)';
  if(!paused){ lastTime = performance.now(); requestAnimationFrame(update); }
}

function restart(){
  arena = createMatrix(COLS, ROWS);
  player.score = 0; player.lines = 0; player.level = 1;
  dropInterval = 1000;
  nextPiece = null;
  gameOver = false; paused = false;
  clearGameOverUI();
  playerReset();
  updateScore();
  document.getElementById('btnPause').textContent = 'Pause (P)';
  lastTime = performance.now();
  requestAnimationFrame(update);
}

function startGame(selectedDifficulty){
  difficulty = selectedDifficulty;
  document.getElementById('difficultyMenu').style.display = 'none';
  document.getElementById('gameContainer').style.display = 'flex';
  if(difficulty === 'easy'){
    document.getElementById('nextPreviewPanel').style.display = 'flex';
  } else {
    document.getElementById('nextPreviewPanel').style.display = 'none';
  }
  restart();
}

function showGameOver(){
  const overlay = document.getElementById('gameOverOverlay');
  overlay.classList.add('active');
  document.getElementById('gameOverScore').textContent = `Score: ${player.score}`;
  document.getElementById('gameOverLevel').textContent = `Level: ${player.level}`;
  document.getElementById('gameOverLines').textContent = `Lines: ${player.lines}`;
  const ui = document.querySelector('.ui');
  ui.classList.add('game-over');
  const restartBtn = document.getElementById('btnRestart');
  restartBtn.classList.add('active');
  restartBtn.disabled = false;
  const pauseBtn = document.getElementById('btnPause');
  pauseBtn.disabled = true;
}

function clearGameOverUI(){
  const overlay = document.getElementById('gameOverOverlay');
  overlay.classList.remove('active');
  const ui = document.querySelector('.ui');
  ui.classList.remove('game-over');
  const restartBtn = document.getElementById('btnRestart');
  restartBtn.classList.remove('active');
  const pauseBtn = document.getElementById('btnPause');
  pauseBtn.disabled = false;
}

// Start - Show difficulty menu
// Game will start after difficulty selection

</script>
</body>
</html>